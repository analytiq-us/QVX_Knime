package edu.njit.qvxreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.transform.stream.StreamSource;

import edu.njit.qvx.QvxTableHeader;
import edu.njit.qvx.QvxTableHeader.Fields.QvxFieldHeader;

public class QvxReader {
	
	/* This a prototype version of QVXReader. It can take a qvx file as input (however,
	 * will ONLY work if qvx file was generated by QVXWriter script (this is because we have no sample
	 * real qvx files to test with).
	 *  and outputs a 2D object array (Object[][])
	 * This qvx file can either be in big-endian or little-endian (needs to be tested) format.
	 * 
	 * Added functionality since last meeting:
	 * Works with various field types
	 * Various edge cases still need to be tested(such as usesSeparatorByte)
	 */
	
	private static QvxTableHeader qvxTableHeader;
	private static String inFileName;
	private static String xmlString;
	private static byte[] buffer;
	private static int bufferSize;
	private static int bufferIndex = 0;
	private static int zeroByteIndex;
	private static List<Object[]> data = new ArrayList<>();
		
	public static Object[][] readFromQvx(String inFileName) {
		
		QvxReader.inFileName = inFileName;
		QvxReader.readQvxTableHeader();
		QvxReader.readBody();	
		return dataTo2DArray();
	}
	
	private static Object[][] dataTo2DArray() {
		
		/* Converts "data" (which is of type List<Object[]>) to Object[][]
		 */
		
		int numFields = data.get(0).length;
		Object[][] returnVal = new Object[data.size()][numFields];
		for(int i = 0; i < data.size(); i++) {
			Object[] row = data.get(i);
			for(int j = 0; j < numFields; j++) {
				returnVal[i][j] = row[j];
			}
		}
		return returnVal;
	}
	
	private static void readQvxTableHeader() {
		
		/* Reads the entire "inFileName", creates QvxTableHeader object, and stores the location of the
		 * zero-byte
		 */
		
		FileInputStream inputStream = null;
		try {
			// Read the entire "inFileName" into a byte[] buffer
			
			//Set bufferSize
			File f = new File(inFileName);
			bufferSize = (int)f.length();
			if (bufferSize < f.length()) { //The case when narrowing conversion causes loss of data
				throw new RuntimeException("File too big");
			}
			
			//Read "inFileName" into "buffer"
			inputStream = new FileInputStream(inFileName);
			buffer = new byte[bufferSize];
			int bytesRead = inputStream.read(buffer);
			if (bytesRead != bufferSize || inputStream.read() != -1) { // If bufferSize is not appropriate; theoretically, should never happen
				inputStream.close();
				throw new RuntimeException("Buffer size is either too big or too small");
			}
			
			// Extract the xml portion of buffer
			zeroByteIndex = indexOf(buffer, (byte)0);
			xmlString = byteArrayToString(Arrays.copyOfRange(buffer, 0, zeroByteIndex));
			
			// Unmarshal "xmlString" into a QvxTableHeader object
			JAXBContext jaxbContext;
			jaxbContext = JAXBContext.newInstance( QvxTableHeader.class );
			Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
			qvxTableHeader = (QvxTableHeader) jaxbUnmarshaller.unmarshal(
					new StreamSource(new StringReader(xmlString)));
			
			//Add field names to "data"
			List<QvxTableHeader.Fields.QvxFieldHeader> fieldHeaders =
					qvxTableHeader.getFields().getQvxFieldHeader();
			String[] fieldNames = new String[fieldHeaders.size()];
			for(int i = 0; i < fieldHeaders.size(); i++) {
				fieldNames[i] = fieldHeaders.get(i).getFieldName();
			}
			data.add(fieldNames);
			
			inputStream.close();
		}
		catch(FileNotFoundException e) { e.printStackTrace(); }
		catch(IOException e) { e.printStackTrace(); }
		catch(JAXBException e) { e.printStackTrace(); }
	}
	
	private static void readBody() {
		
		/* Reads the body of the qvx file and populates "data"
		 */
		
		int numFields = qvxTableHeader.getFields().getQvxFieldHeader().size();
		bufferIndex = zeroByteIndex + 1; //Starting index of the body
		while(bufferIndex < buffer.length) { //Keep reading until the end of the body is reached
			Object[] row = new Object[numFields];
			for(int i = 0; i < numFields; i++) { //Read each field
				QvxFieldHeader fieldHeader = qvxTableHeader.getFields().getQvxFieldHeader().get(i);			
				row[i] = readValueFromBuffer(fieldHeader);
			}
			data.add(row);
		}
			
	}
	
	private static Object readValueFromBuffer(QvxFieldHeader fieldHeader) {
		
		int byteWidth = fieldHeader.getByteWidth().intValue();
		ByteOrder byteOrder = fieldHeader.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
		switch (fieldHeader.getType()) {
			case QVX_BLOB:
				//TODO
				return null;
			case QVX_IEEE_REAL:
				if (byteWidth == 4) {
					return ByteBuffer.wrap(readBytesFromBuffer(4)).order(byteOrder).getFloat();
				}else if(byteWidth == 8) {
					return ByteBuffer.wrap(readBytesFromBuffer(8)).order(byteOrder).getDouble();
				}
			case QVX_PACKED_BCD:
				//TODO
				return null;
			case QVX_UNSIGNED_INTEGER:
			case QVX_SIGNED_INTEGER:
				if (byteWidth == 1) {
					// TODO
				}else if(byteWidth == 2) {
					return ByteBuffer.wrap(readBytesFromBuffer(2)).order(byteOrder).getShort();
				}else if(byteWidth == 4) {
					return ByteBuffer.wrap(readBytesFromBuffer(4)).order(byteOrder).getInt();
				}else if(byteWidth == 8) {
					return ByteBuffer.wrap(readBytesFromBuffer(8)).order(byteOrder).getLong();
				}
			case QVX_TEXT:
				return bufferToString_zeroTerminated();
			default:
				return null;
		}
	}
	//Helper methods ------------------------------------
	
	private static String byteArrayToString(byte[] bytes) {
		
		/* Converts each byte in bytes into a character, then concatenates all of these characters
		 */
		
		String s = "";
		for(int i = 0; i < bytes.length; i++) {
			s += (char)bytes[i];
		}
		return s;
	}
	
	private static int indexOf(byte[] bytes, byte search) {
		
		/* Returns the index of the first occurrence of "search" in bytes
		 * */
		
		for(int i = 0; i < bytes.length; i++) {
			if (bytes[i] == search) {
				return i;
			}
		}
		return -1;
	}
	
	private static byte[] readBytesFromBuffer(int n) {
		
		byte[] bytes = Arrays.copyOfRange(buffer, bufferIndex, bufferIndex + n);
		bufferIndex += n;
		return bytes;
	}
	
	private static String bufferToString_zeroTerminated() {
		
		String s = "";
		byte b;
		while ((b = buffer[bufferIndex++]) != 0 ) {
			s += (char)b;
		}
		return s;
	}
}